{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport { __awaiter, __extends, __generator } from \"tslib\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { Constants } from \"../util/constants\";\nimport { delay } from \"../util/utils\";\nvar StatusCodes = Constants.HttpConstants.StatusCodes;\nvar DEFAULT_RETRY_COUNT = 3;\nexport function throttlingRetryPolicy(maxRetries) {\n  if (maxRetries === void 0) {\n    maxRetries = DEFAULT_RETRY_COUNT;\n  }\n  return {\n    create: function (nextPolicy, options) {\n      return new ThrottlingRetryPolicy(nextPolicy, options, maxRetries);\n    }\n  };\n}\n/**\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\nvar ThrottlingRetryPolicy = /** @class */function (_super) {\n  __extends(ThrottlingRetryPolicy, _super);\n  function ThrottlingRetryPolicy(nextPolicy, options, retryLimit) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n    _this.retryLimit = retryLimit;\n    return _this;\n  }\n  ThrottlingRetryPolicy.prototype.sendRequest = function (httpRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this._nextPolicy.sendRequest(httpRequest.clone()).then(function (response) {\n          return _this.retry(httpRequest, response, 0);\n        })];\n      });\n    });\n  };\n  ThrottlingRetryPolicy.prototype.retry = function (httpRequest, httpResponse, retryCount) {\n    return __awaiter(this, void 0, void 0, function () {\n      var retryAfterHeader, delayInMs, res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (httpResponse.status !== StatusCodes.TooManyRequests) {\n              return [2 /*return*/, httpResponse];\n            }\n            retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER);\n            if (!(retryAfterHeader && retryCount < this.retryLimit)) return [3 /*break*/, 3];\n            delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);\n            if (!delayInMs) return [3 /*break*/, 3];\n            return [4 /*yield*/, delay(delayInMs)];\n          case 1:\n            _a.sent();\n            return [4 /*yield*/, this._nextPolicy.sendRequest(httpRequest)];\n          case 2:\n            res = _a.sent();\n            return [2 /*return*/, this.retry(httpRequest, res, retryCount + 1)];\n          case 3:\n            return [2 /*return*/, httpResponse];\n        }\n      });\n    });\n  };\n  ThrottlingRetryPolicy.parseRetryAfterHeader = function (headerValue) {\n    var retryAfterInSeconds = Number(headerValue);\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  };\n  ThrottlingRetryPolicy.parseDateRetryAfterHeader = function (headerValue) {\n    try {\n      var now = Date.now();\n      var date = Date.parse(headerValue);\n      var diff = date - now;\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error) {\n      return undefined;\n    }\n  };\n  return ThrottlingRetryPolicy;\n}(BaseRequestPolicy);\nexport { ThrottlingRetryPolicy };","map":{"version":3,"mappings":"AAAA;AACA;;AAEA,SACEA,iBAAiB,QAIZ,iBAAiB;AAGxB,SAASC,SAAS,QAAQ,mBAAmB;AAC7C,SAASC,KAAK,QAAQ,eAAe;AAErC,IAAMC,WAAW,GAAGF,SAAS,CAACG,aAAa,CAACD,WAAW;AACvD,IAAME,mBAAmB,GAAG,CAAC;AAY7B,OAAM,SAAUC,qBAAqB,CACnCC,UAAwC;EAAxC;IAAAA,gCAAwC;EAAA;EAExC,OAAO;IACLC,MAAM,EAAE,UAACC,UAAyB,EAAEC,OAAiC;MACnE,OAAO,IAAIC,qBAAqB,CAACF,UAAU,EAAEC,OAAO,EAAEH,UAAU,CAAC;IACnE;GACD;AACH;AAEA;;;;;;AAMA;EAA2CK;EAGzC,+BAAYH,UAAyB,EAAEC,OAAiC,EAAEG,UAAkB;IAA5F,YACEC,kBAAML,UAAU,EAAEC,OAAO,CAAC;IAC1BK,KAAI,CAACF,UAAU,GAAGA,UAAU;;EAC9B;EAEaF,2CAAW,GAAxB,UAAyBK,WAA4B;;;;QACnD,sBAAO,IAAI,CAACC,WAAW,CAACC,WAAW,CAACF,WAAW,CAACG,KAAK,EAAE,CAAC,CAACC,IAAI,CAAC,UAACC,QAAQ;UACrE,OAAON,KAAI,CAACO,KAAK,CAACN,WAAW,EAAEK,QAAQ,EAAE,CAAC,CAAC;QAC7C,CAAC,CAAC;;;GACH;EAEaV,qCAAK,GAAnB,UACEK,WAA4B,EAC5BO,YAAmC,EACnCC,UAAkB;;;;;;YAElB,IAAID,YAAY,CAACE,MAAM,KAAKtB,WAAW,CAACuB,eAAe,EAAE;cACvD,sBAAOH,YAAY;;YAGfI,gBAAgB,GAAuBJ,YAAY,CAACK,OAAO,CAACC,GAAG,CACnE5B,SAAS,CAAC6B,eAAe,CAACC,WAAW,CACtC;kBAEGJ,gBAAgB,IAAIH,UAAU,GAAG,IAAI,CAACX,UAAU,GAAhD;YACImB,SAAS,GAAuBrB,qBAAqB,CAACsB,qBAAqB,CAC/EN,gBAAgB,CACjB;iBACGK,SAAS,EAAT;YACF,qBAAM9B,KAAK,CAAC8B,SAAS,CAAC;;YAAtBE,SAAsB;YACV,qBAAM,IAAI,CAACjB,WAAW,CAACC,WAAW,CAACF,WAAW,CAAC;;YAArDmB,GAAG,GAAGD,SAA+C;YAC3D,sBAAO,IAAI,CAACZ,KAAK,CAACN,WAAW,EAAEmB,GAAG,EAAEX,UAAU,GAAG,CAAC,CAAC;;YAIvD,sBAAOD,YAAY;QAAC;;;GACrB;EAEaZ,2CAAqB,GAAnC,UAAoCyB,WAAmB;IACrD,IAAMC,mBAAmB,GAAGC,MAAM,CAACF,WAAW,CAAC;IAC/C,IAAIE,MAAM,CAACC,KAAK,CAACF,mBAAmB,CAAC,EAAE;MACrC,OAAO1B,qBAAqB,CAAC6B,yBAAyB,CAACJ,WAAW,CAAC;KACpE,MAAM;MACL,OAAOC,mBAAmB,GAAG,IAAI;;EAErC,CAAC;EAEa1B,+CAAyB,GAAvC,UAAwCyB,WAAmB;IACzD,IAAI;MACF,IAAMK,GAAG,GAAWC,IAAI,CAACD,GAAG,EAAE;MAC9B,IAAME,IAAI,GAAWD,IAAI,CAACE,KAAK,CAACR,WAAW,CAAC;MAC5C,IAAMS,IAAI,GAAGF,IAAI,GAAGF,GAAG;MAEvB,OAAOH,MAAM,CAACC,KAAK,CAACM,IAAI,CAAC,GAAGC,SAAS,GAAGD,IAAI;KAC7C,CAAC,OAAOE,KAAK,EAAE;MACd,OAAOD,SAAS;;EAEpB,CAAC;EACH,4BAAC;AAAD,CAAC,CA7D0C9C,iBAAiB","names":["BaseRequestPolicy","Constants","delay","StatusCodes","HttpConstants","DEFAULT_RETRY_COUNT","throttlingRetryPolicy","maxRetries","create","nextPolicy","options","ThrottlingRetryPolicy","__extends","retryLimit","_super","_this","httpRequest","_nextPolicy","sendRequest","clone","then","response","retry","httpResponse","retryCount","status","TooManyRequests","retryAfterHeader","headers","get","HeaderConstants","RETRY_AFTER","delayInMs","parseRetryAfterHeader","_a","res","headerValue","retryAfterInSeconds","Number","isNaN","parseDateRetryAfterHeader","now","Date","date","parse","diff","undefined","error"],"sources":["C:\\Users\\willi\\Downloads\\azure-main\\node_modules\\@azure\\ms-rest-js\\lib\\policies\\throttlingRetryPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptionsLike,\n  RequestPolicyFactory,\n} from \"./requestPolicy\";\nimport { WebResourceLike } from \"../webResource\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { Constants } from \"../util/constants\";\nimport { delay } from \"../util/utils\";\n\nconst StatusCodes = Constants.HttpConstants.StatusCodes;\nconst DEFAULT_RETRY_COUNT = 3;\n\n/**\n * Options that control how to retry on response status code 429.\n */\nexport interface ThrottlingRetryOptions {\n  /**\n   * The maximum number of retry attempts.  Defaults to 3.\n   */\n  maxRetries?: number;\n}\n\nexport function throttlingRetryPolicy(\n  maxRetries: number = DEFAULT_RETRY_COUNT\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptionsLike) => {\n      return new ThrottlingRetryPolicy(nextPolicy, options, maxRetries);\n    },\n  };\n}\n\n/**\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\nexport class ThrottlingRetryPolicy extends BaseRequestPolicy {\n  private retryLimit: number;\n\n  constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptionsLike, retryLimit: number) {\n    super(nextPolicy, options);\n    this.retryLimit = retryLimit;\n  }\n\n  public async sendRequest(httpRequest: WebResourceLike): Promise<HttpOperationResponse> {\n    return this._nextPolicy.sendRequest(httpRequest.clone()).then((response) => {\n      return this.retry(httpRequest, response, 0);\n    });\n  }\n\n  private async retry(\n    httpRequest: WebResourceLike,\n    httpResponse: HttpOperationResponse,\n    retryCount: number\n  ): Promise<HttpOperationResponse> {\n    if (httpResponse.status !== StatusCodes.TooManyRequests) {\n      return httpResponse;\n    }\n\n    const retryAfterHeader: string | undefined = httpResponse.headers.get(\n      Constants.HeaderConstants.RETRY_AFTER\n    );\n\n    if (retryAfterHeader && retryCount < this.retryLimit) {\n      const delayInMs: number | undefined = ThrottlingRetryPolicy.parseRetryAfterHeader(\n        retryAfterHeader\n      );\n      if (delayInMs) {\n        await delay(delayInMs);\n        const res = await this._nextPolicy.sendRequest(httpRequest);\n        return this.retry(httpRequest, res, retryCount + 1);\n      }\n    }\n\n    return httpResponse;\n  }\n\n  public static parseRetryAfterHeader(headerValue: string): number | undefined {\n    const retryAfterInSeconds = Number(headerValue);\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  }\n\n  public static parseDateRetryAfterHeader(headerValue: string): number | undefined {\n    try {\n      const now: number = Date.now();\n      const date: number = Date.parse(headerValue);\n      const diff = date - now;\n\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error) {\n      return undefined;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}