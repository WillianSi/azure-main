{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport { __extends } from \"tslib\";\nimport * as utils from \"../util/utils\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { RestError } from \"../restError\";\nexport function exponentialRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n  return {\n    create: function (nextPolicy, options) {\n      return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\n    }\n  };\n}\nvar DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\nvar DEFAULT_CLIENT_RETRY_COUNT = 3;\nvar DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\nvar DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n/**\n * @class\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\nvar ExponentialRetryPolicy = /** @class */function (_super) {\n  __extends(ExponentialRetryPolicy, _super);\n  /**\n   * @constructor\n   * @param {RequestPolicy} nextPolicy The next RequestPolicy in the pipeline chain.\n   * @param {RequestPolicyOptionsLike} options The options for this RequestPolicy.\n   * @param {number} [retryCount]        The client retry count.\n   * @param {number} [retryInterval]     The client retry interval, in milliseconds.\n   * @param {number} [minRetryInterval]  The minimum retry interval, in milliseconds.\n   * @param {number} [maxRetryInterval]  The maximum retry interval, in milliseconds.\n   */\n  function ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n    function isNumber(n) {\n      return typeof n === \"number\";\n    }\n    _this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    _this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    _this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    _this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n    return _this;\n  }\n  ExponentialRetryPolicy.prototype.sendRequest = function (request) {\n    var _this = this;\n    return this._nextPolicy.sendRequest(request.clone()).then(function (response) {\n      return retry(_this, request, response);\n    }).catch(function (error) {\n      return retry(_this, request, error.response, undefined, error);\n    });\n  };\n  return ExponentialRetryPolicy;\n}(BaseRequestPolicy);\nexport { ExponentialRetryPolicy };\n/**\n * Determines if the operation should be retried and how long to wait until the next retry.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {number} statusCode The HTTP status code.\n * @param {RetryData} retryData  The retry data.\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n */\nfunction shouldRetry(policy, statusCode, retryData) {\n  if (statusCode == undefined || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) {\n    return false;\n  }\n  var currentCount;\n  if (!retryData) {\n    throw new Error(\"retryData for the ExponentialRetryPolicyFilter cannot be null.\");\n  } else {\n    currentCount = retryData && retryData.retryCount;\n  }\n  return currentCount < policy.retryCount;\n}\n/**\n * Updates the retry data for the next attempt.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {RetryData} retryData  The retry data.\n * @param {RetryError} [err] The operation\"s error, if any.\n */\nfunction updateRetryData(policy, retryData, err) {\n  if (!retryData) {\n    retryData = {\n      retryCount: 0,\n      retryInterval: 0\n    };\n  }\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n    retryData.error = err;\n  }\n  // Adjust retry count\n  retryData.retryCount++;\n  // Adjust retry interval\n  var incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n  var boundedRandDelta = policy.retryInterval * 0.8 + Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));\n  incrementDelta *= boundedRandDelta;\n  retryData.retryInterval = Math.min(policy.minRetryInterval + incrementDelta, policy.maxRetryInterval);\n  return retryData;\n}\nfunction retry(policy, request, response, retryData, requestError) {\n  retryData = updateRetryData(policy, retryData, requestError);\n  var isAborted = request.abortSignal && request.abortSignal.aborted;\n  if (!isAborted && shouldRetry(policy, response && response.status, retryData)) {\n    return utils.delay(retryData.retryInterval).then(function () {\n      return policy._nextPolicy.sendRequest(request.clone());\n    }).then(function (res) {\n      return retry(policy, request, res, retryData, undefined);\n    }).catch(function (err) {\n      return retry(policy, request, response, retryData, err);\n    });\n  } else if (isAborted || requestError || !response) {\n    // If the operation failed in the end, return all errors instead of just the last one\n    var err = retryData.error || new RestError(\"Failed to send the request.\", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);\n    return Promise.reject(err);\n  } else {\n    return Promise.resolve(response);\n  }\n}","map":{"version":3,"mappings":"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","names":["utils","BaseRequestPolicy","RestError","exponentialRetryPolicy","retryCount","retryInterval","minRetryInterval","maxRetryInterval","create","nextPolicy","options","ExponentialRetryPolicy","DEFAULT_CLIENT_RETRY_INTERVAL","DEFAULT_CLIENT_RETRY_COUNT","DEFAULT_CLIENT_MAX_RETRY_INTERVAL","DEFAULT_CLIENT_MIN_RETRY_INTERVAL","__extends","_super","isNumber","n","_this","request","_nextPolicy","sendRequest","clone","then","response","catch","error","undefined","shouldRetry","policy","statusCode","retryData","currentCount","Error","updateRetryData","err","innerError","incrementDelta","Math","pow","boundedRandDelta","floor","random","min","retry","requestError","isAborted","abortSignal","aborted","status","delay","res","REQUEST_SEND_ERROR","Promise","reject","resolve"],"sources":["C:\\Users\\willi\\Downloads\\azure-main\\node_modules\\@azure\\ms-rest-js\\lib\\policies\\exponentialRetryPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport * as utils from \"../util/utils\";\nimport { WebResourceLike } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptionsLike,\n} from \"./requestPolicy\";\nimport { RestError } from \"../restError\";\n\nexport interface RetryData {\n  retryCount: number;\n  retryInterval: number;\n  error?: RetryError;\n}\n\nexport interface RetryError extends Error {\n  message: string;\n  code?: string;\n  innerError?: RetryError;\n}\n\nexport function exponentialRetryPolicy(\n  retryCount?: number,\n  retryInterval?: number,\n  minRetryInterval?: number,\n  maxRetryInterval?: number\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptionsLike) => {\n      return new ExponentialRetryPolicy(\n        nextPolicy,\n        options,\n        retryCount,\n        retryInterval,\n        minRetryInterval,\n        maxRetryInterval\n      );\n    },\n  };\n}\n\nconst DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\nconst DEFAULT_CLIENT_RETRY_COUNT = 3;\nconst DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\nconst DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n\n/**\n * @class\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\nexport class ExponentialRetryPolicy extends BaseRequestPolicy {\n  /**\n   * The client retry count.\n   */\n  retryCount: number;\n  /**\n   * The client retry interval in milliseconds.\n   */\n  retryInterval: number;\n  /**\n   * The minimum retry interval in milliseconds.\n   */\n  minRetryInterval: number;\n  /**\n   * The maximum retry interval in milliseconds.\n   */\n  maxRetryInterval: number;\n\n  /**\n   * @constructor\n   * @param {RequestPolicy} nextPolicy The next RequestPolicy in the pipeline chain.\n   * @param {RequestPolicyOptionsLike} options The options for this RequestPolicy.\n   * @param {number} [retryCount]        The client retry count.\n   * @param {number} [retryInterval]     The client retry interval, in milliseconds.\n   * @param {number} [minRetryInterval]  The minimum retry interval, in milliseconds.\n   * @param {number} [maxRetryInterval]  The maximum retry interval, in milliseconds.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptionsLike,\n    retryCount?: number,\n    retryInterval?: number,\n    minRetryInterval?: number,\n    maxRetryInterval?: number\n  ) {\n    super(nextPolicy, options);\n    function isNumber(n: any): n is number {\n      return typeof n === \"number\";\n    }\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.minRetryInterval = isNumber(minRetryInterval)\n      ? minRetryInterval\n      : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval)\n      ? maxRetryInterval\n      : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  public sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .then((response) => retry(this, request, response))\n      .catch((error) => retry(this, request, error.response, undefined, error));\n  }\n}\n\n/**\n * Determines if the operation should be retried and how long to wait until the next retry.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {number} statusCode The HTTP status code.\n * @param {RetryData} retryData  The retry data.\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n */\nfunction shouldRetry(\n  policy: ExponentialRetryPolicy,\n  statusCode: number | undefined,\n  retryData: RetryData\n): boolean {\n  if (\n    statusCode == undefined ||\n    (statusCode < 500 && statusCode !== 408) ||\n    statusCode === 501 ||\n    statusCode === 505\n  ) {\n    return false;\n  }\n\n  let currentCount: number;\n  if (!retryData) {\n    throw new Error(\"retryData for the ExponentialRetryPolicyFilter cannot be null.\");\n  } else {\n    currentCount = retryData && retryData.retryCount;\n  }\n\n  return currentCount < policy.retryCount;\n}\n\n/**\n * Updates the retry data for the next attempt.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {RetryData} retryData  The retry data.\n * @param {RetryError} [err] The operation\"s error, if any.\n */\nfunction updateRetryData(\n  policy: ExponentialRetryPolicy,\n  retryData?: RetryData,\n  err?: RetryError\n): RetryData {\n  if (!retryData) {\n    retryData = {\n      retryCount: 0,\n      retryInterval: 0,\n    };\n  }\n\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  }\n\n  // Adjust retry count\n  retryData.retryCount++;\n\n  // Adjust retry interval\n  let incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n  const boundedRandDelta =\n    policy.retryInterval * 0.8 +\n    Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));\n  incrementDelta *= boundedRandDelta;\n\n  retryData.retryInterval = Math.min(\n    policy.minRetryInterval + incrementDelta,\n    policy.maxRetryInterval\n  );\n\n  return retryData;\n}\n\nfunction retry(\n  policy: ExponentialRetryPolicy,\n  request: WebResourceLike,\n  response?: HttpOperationResponse,\n  retryData?: RetryData,\n  requestError?: RetryError\n): Promise<HttpOperationResponse> {\n  retryData = updateRetryData(policy, retryData, requestError);\n  const isAborted: boolean | undefined = request.abortSignal && request.abortSignal.aborted;\n  if (!isAborted && shouldRetry(policy, response && response.status, retryData)) {\n    return utils\n      .delay(retryData.retryInterval)\n      .then(() => policy._nextPolicy.sendRequest(request.clone()))\n      .then((res) => retry(policy, request, res, retryData, undefined))\n      .catch((err) => retry(policy, request, response, retryData, err));\n  } else if (isAborted || requestError || !response) {\n    // If the operation failed in the end, return all errors instead of just the last one\n    const err =\n      retryData.error ||\n      new RestError(\n        \"Failed to send the request.\",\n        RestError.REQUEST_SEND_ERROR,\n        response && response.status,\n        response && response.request,\n        response\n      );\n    return Promise.reject(err);\n  } else {\n    return Promise.resolve(response);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}