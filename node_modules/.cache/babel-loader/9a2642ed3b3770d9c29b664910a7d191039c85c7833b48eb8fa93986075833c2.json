{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nvar _a, _b;\nvar parser = new DOMParser();\n// Policy to make our code Trusted Types compliant.\n//   https://github.com/w3c/webappsec-trusted-types\n// We are calling DOMParser.parseFromString() to parse XML payload from Azure services.\n// The parsed DOM object is not exposed to outside. Scripts are disabled when parsing\n// according to the spec.  There are no HTML/XSS security concerns on the usage of\n// parseFromString() here.\nvar ttPolicy;\nif (typeof self.trustedTypes !== \"undefined\") {\n  ttPolicy = self.trustedTypes.createPolicy(\"@azure/ms-rest-js#xml.browser\", {\n    createHTML: function (s) {\n      return s;\n    }\n  });\n}\nexport function parseXML(str) {\n  var _a;\n  try {\n    var dom = parser.parseFromString((_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(str)) !== null && _a !== void 0 ? _a : str, \"application/xml\");\n    throwIfError(dom);\n    var obj = domToObject(dom.childNodes[0]);\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nvar errorNS = \"\";\ntry {\n  var invalidXML = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(\"INVALID\")) !== null && _a !== void 0 ? _a : \"INVALID\";\n  errorNS = (_b = parser.parseFromString(invalidXML, \"text/xml\").getElementsByTagName(\"parsererror\")[0].namespaceURI) !== null && _b !== void 0 ? _b : \"\";\n} catch (ignored) {\n  // Most browsers will return a document containing <parsererror>, but IE will throw.\n}\nfunction throwIfError(dom) {\n  if (errorNS) {\n    var parserErrors = dom.getElementsByTagNameNS(errorNS, \"parsererror\");\n    if (parserErrors.length) {\n      throw new Error(parserErrors.item(0).innerHTML);\n    }\n  }\n}\nfunction isElement(node) {\n  return !!node.attributes;\n}\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node) {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\nfunction domToObject(node) {\n  var result = {};\n  var childNodeCount = node.childNodes.length;\n  var firstChildNode = node.childNodes[0];\n  var onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || undefined;\n  var elementWithAttributes = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[\"$\"] = {};\n    for (var i = 0; i < elementWithAttributes.attributes.length; i++) {\n      var attr = elementWithAttributes.attributes[i];\n      result[\"$\"][attr.nodeName] = attr.nodeValue;\n    }\n    if (onlyChildTextValue) {\n      result[\"_\"] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n  if (!onlyChildTextValue) {\n    for (var i = 0; i < childNodeCount; i++) {\n      var child = node.childNodes[i];\n      // Ignore leading/trailing whitespace nodes\n      if (child.nodeType !== Node.TEXT_NODE) {\n        var childObject = domToObject(child);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n  return result;\n}\n// tslint:disable-next-line:no-null-keyword\nvar doc = document.implementation.createDocument(null, null, null);\nvar serializer = new XMLSerializer();\nexport function stringifyXML(obj, opts) {\n  var rootName = opts && opts.rootName || \"root\";\n  var dom = buildNode(obj, rootName)[0];\n  return '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + serializer.serializeToString(dom);\n}\nfunction buildAttributes(attrs) {\n  var result = [];\n  for (var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++) {\n    var key = _a[_i];\n    var attr = doc.createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\nfunction buildNode(obj, elementName) {\n  if (typeof obj === \"string\" || typeof obj === \"number\" || typeof obj === \"boolean\") {\n    var elem = doc.createElement(elementName);\n    elem.textContent = obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    var result = [];\n    for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {\n      var arrayElem = obj_1[_i];\n      for (var _a = 0, _b = buildNode(arrayElem, elementName); _a < _b.length; _a++) {\n        var child = _b[_a];\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    var elem = doc.createElement(elementName);\n    for (var _c = 0, _d = Object.keys(obj); _c < _d.length; _c++) {\n      var key = _d[_c];\n      if (key === \"$\") {\n        for (var _e = 0, _f = buildAttributes(obj[key]); _e < _f.length; _e++) {\n          var attr = _f[_e];\n          elem.attributes.setNamedItem(attr);\n        }\n      } else {\n        for (var _g = 0, _h = buildNode(obj[key], key); _g < _h.length; _g++) {\n          var child = _h[_g];\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(\"Illegal value passed to buildObject: \" + obj);\n  }\n}","map":{"version":3,"mappings":"AAAA;AACA;;AAEA,IAAMA,MAAM,GAAG,IAAIC,SAAS,EAAE;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,QAA2D;AAC/D,IAAI,OAAOC,IAAI,CAACC,YAAY,KAAK,WAAW,EAAE;EAC5CF,QAAQ,GAAGC,IAAI,CAACC,YAAY,CAACC,YAAY,CAAC,+BAA+B,EAAE;IACzEC,UAAU,EAAE,UAACC,CAAC;MAAK,QAAC;IAAD;GACpB,CAAC;;AAGJ,OAAM,SAAUC,QAAQ,CAACC,GAAW;;EAClC,IAAI;IACF,IAAMC,GAAG,GAAGV,MAAM,CAACW,eAAe,CAAC,MAACT,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEI,UAAU,CAACG,GAAG,oCAAKA,GAAG,EAAa,iBAAiB,CAAC;IACnGG,YAAY,CAACF,GAAG,CAAC;IAEjB,IAAMG,GAAG,GAAGC,WAAW,CAACJ,GAAG,CAACK,UAAU,CAAC,CAAC,CAAC,CAAC;IAC1C,OAAOC,OAAO,CAACC,OAAO,CAACJ,GAAG,CAAC;GAC5B,CAAC,OAAOK,GAAG,EAAE;IACZ,OAAOF,OAAO,CAACG,MAAM,CAACD,GAAG,CAAC;;AAE9B;AAEA,IAAIE,OAAO,GAAG,EAAE;AAChB,IAAI;EACF,IAAMC,UAAU,GAAG,MAACnB,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEI,UAAU,CAAC,SAAS,oCAAK,SAAoB;EAC3Ec,OAAO,SACLpB,MAAM,CAACW,eAAe,CAACU,UAAU,EAAE,UAAU,CAAC,CAACC,oBAAoB,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAClFC,YAAa,mCAAI,EAAE;CACzB,CAAC,OAAOC,OAAO,EAAE;EAChB;AAAA;AAGF,SAASZ,YAAY,CAACF,GAAa;EACjC,IAAIU,OAAO,EAAE;IACX,IAAMK,YAAY,GAAGf,GAAG,CAACgB,sBAAsB,CAACN,OAAO,EAAE,aAAa,CAAC;IACvE,IAAIK,YAAY,CAACE,MAAM,EAAE;MACvB,MAAM,IAAIC,KAAK,CAACH,YAAY,CAACI,IAAI,CAAC,CAAC,CAAE,CAACC,SAAS,CAAC;;;AAGtD;AAEA,SAASC,SAAS,CAACC,IAAU;EAC3B,OAAO,CAAC,CAAEA,IAAgB,CAACC,UAAU;AACvC;AAEA;;;;AAIA,SAASC,uBAAuB,CAACF,IAAU;EACzC,OAAOD,SAAS,CAACC,IAAI,CAAC,IAAIA,IAAI,CAACG,aAAa,EAAE,GAAGH,IAAI,GAAGI,SAAS;AACnE;AAEA,SAAStB,WAAW,CAACkB,IAAU;EAC7B,IAAIK,MAAM,GAAQ,EAAE;EAEpB,IAAMC,cAAc,GAAWN,IAAI,CAACjB,UAAU,CAACY,MAAM;EAErD,IAAMY,cAAc,GAASP,IAAI,CAACjB,UAAU,CAAC,CAAC,CAAC;EAC/C,IAAMyB,kBAAkB,GACrBD,cAAc,IACbD,cAAc,KAAK,CAAC,IACpBC,cAAc,CAACE,QAAQ,KAAKC,IAAI,CAACC,SAAS,IAC1CJ,cAAc,CAACK,SAAS,IAC1BR,SAAS;EAEX,IAAMS,qBAAqB,GAAwBX,uBAAuB,CAACF,IAAI,CAAC;EAChF,IAAIa,qBAAqB,EAAE;IACzBR,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE;IAEhB,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,qBAAqB,CAACZ,UAAU,CAACN,MAAM,EAAEmB,CAAC,EAAE,EAAE;MAChE,IAAMC,IAAI,GAAGF,qBAAqB,CAACZ,UAAU,CAACa,CAAC,CAAC;MAChDT,MAAM,CAAC,GAAG,CAAC,CAACU,IAAI,CAACC,QAAQ,CAAC,GAAGD,IAAI,CAACH,SAAS;;IAG7C,IAAIJ,kBAAkB,EAAE;MACtBH,MAAM,CAAC,GAAG,CAAC,GAAGG,kBAAkB;;GAEnC,MAAM,IAAIF,cAAc,KAAK,CAAC,EAAE;IAC/BD,MAAM,GAAG,EAAE;GACZ,MAAM,IAAIG,kBAAkB,EAAE;IAC7BH,MAAM,GAAGG,kBAAkB;;EAG7B,IAAI,CAACA,kBAAkB,EAAE;IACvB,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,cAAc,EAAEQ,CAAC,EAAE,EAAE;MACvC,IAAMG,KAAK,GAAGjB,IAAI,CAACjB,UAAU,CAAC+B,CAAC,CAAC;MAChC;MACA,IAAIG,KAAK,CAACR,QAAQ,KAAKC,IAAI,CAACC,SAAS,EAAE;QACrC,IAAMO,WAAW,GAAQpC,WAAW,CAACmC,KAAK,CAAC;QAC3C,IAAI,CAACZ,MAAM,CAACY,KAAK,CAACD,QAAQ,CAAC,EAAE;UAC3BX,MAAM,CAACY,KAAK,CAACD,QAAQ,CAAC,GAAGE,WAAW;SACrC,MAAM,IAAIC,KAAK,CAACC,OAAO,CAACf,MAAM,CAACY,KAAK,CAACD,QAAQ,CAAC,CAAC,EAAE;UAChDX,MAAM,CAACY,KAAK,CAACD,QAAQ,CAAC,CAACK,IAAI,CAACH,WAAW,CAAC;SACzC,MAAM;UACLb,MAAM,CAACY,KAAK,CAACD,QAAQ,CAAC,GAAG,CAACX,MAAM,CAACY,KAAK,CAACD,QAAQ,CAAC,EAAEE,WAAW,CAAC;;;;;EAMtE,OAAOb,MAAM;AACf;AAEA;AACA,IAAMiB,GAAG,GAAGC,QAAQ,CAACC,cAAc,CAACC,cAAc,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AACpE,IAAMC,UAAU,GAAG,IAAIC,aAAa,EAAE;AAEtC,OAAM,SAAUC,YAAY,CAAC/C,GAAQ,EAAEgD,IAA4B;EACjE,IAAMC,QAAQ,GAAID,IAAI,IAAIA,IAAI,CAACC,QAAQ,IAAK,MAAM;EAClD,IAAMpD,GAAG,GAAGqD,SAAS,CAAClD,GAAG,EAAEiD,QAAQ,CAAC,CAAC,CAAC,CAAC;EACvC,OACE,yDAAyD,GAAGJ,UAAU,CAACM,iBAAiB,CAACtD,GAAG,CAAC;AAEjG;AAEA,SAASuD,eAAe,CAACC,KAAgD;EACvE,IAAM7B,MAAM,GAAG,EAAE;EACjB,KAAkB,UAAkB,EAAlB8B,WAAM,CAACC,IAAI,CAACF,KAAK,CAAC,EAAlBG,cAAkB,EAAlBA,IAAkB,EAAE;IAAjC,IAAMC,GAAG;IACZ,IAAMvB,IAAI,GAAGO,GAAG,CAACiB,eAAe,CAACD,GAAG,CAAC;IACrCvB,IAAI,CAACyB,KAAK,GAAGN,KAAK,CAACI,GAAG,CAAC,CAACG,QAAQ,EAAE;IAClCpC,MAAM,CAACgB,IAAI,CAACN,IAAI,CAAC;;EAEnB,OAAOV,MAAM;AACf;AAEA,SAAS0B,SAAS,CAAClD,GAAQ,EAAE6D,WAAmB;EAC9C,IAAI,OAAO7D,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,SAAS,EAAE;IAClF,IAAM8D,IAAI,GAAGrB,GAAG,CAACsB,aAAa,CAACF,WAAW,CAAC;IAC3CC,IAAI,CAACE,WAAW,GAAGhE,GAAG,CAAC4D,QAAQ,EAAE;IACjC,OAAO,CAACE,IAAI,CAAC;GACd,MAAM,IAAIxB,KAAK,CAACC,OAAO,CAACvC,GAAG,CAAC,EAAE;IAC7B,IAAMwB,MAAM,GAAG,EAAE;IACjB,KAAwB,UAAG,EAAHyC,WAAG,EAAHT,iBAAG,EAAHA,IAAG,EAAE;MAAxB,IAAMU,SAAS;MAClB,KAAoB,UAAiC,EAAjCC,cAAS,CAACD,SAAS,EAAEL,WAAW,CAAC,EAAjCP,cAAiC,EAAjCA,IAAiC,EAAE;QAAlD,IAAMlB,KAAK;QACdZ,MAAM,CAACgB,IAAI,CAACJ,KAAK,CAAC;;;IAGtB,OAAOZ,MAAM;GACd,MAAM,IAAI,OAAOxB,GAAG,KAAK,QAAQ,EAAE;IAClC,IAAM8D,IAAI,GAAGrB,GAAG,CAACsB,aAAa,CAACF,WAAW,CAAC;IAC3C,KAAkB,UAAgB,EAAhBO,WAAM,CAACb,IAAI,CAACvD,GAAG,CAAC,EAAhBqE,cAAgB,EAAhBA,IAAgB,EAAE;MAA/B,IAAMZ,GAAG;MACZ,IAAIA,GAAG,KAAK,GAAG,EAAE;QACf,KAAmB,UAAyB,EAAzBa,oBAAe,CAACtE,GAAG,CAACyD,GAAG,CAAC,CAAC,EAAzBc,cAAyB,EAAzBA,IAAyB,EAAE;UAAzC,IAAMrC,IAAI;UACb4B,IAAI,CAAC1C,UAAU,CAACoD,YAAY,CAACtC,IAAI,CAAC;;OAErC,MAAM;QACL,KAAoB,UAAwB,EAAxBuC,cAAS,CAACzE,GAAG,CAACyD,GAAG,CAAC,EAAEA,GAAG,CAAC,EAAxBiB,cAAwB,EAAxBA,IAAwB,EAAE;UAAzC,IAAMtC,KAAK;UACd0B,IAAI,CAACa,WAAW,CAACvC,KAAK,CAAC;;;;IAI7B,OAAO,CAAC0B,IAAI,CAAC;GACd,MAAM;IACL,MAAM,IAAI/C,KAAK,CAAC,0CAAwCf,GAAK,CAAC;;AAElE","names":["parser","DOMParser","ttPolicy","self","trustedTypes","createPolicy","createHTML","s","parseXML","str","dom","parseFromString","throwIfError","obj","domToObject","childNodes","Promise","resolve","err","reject","errorNS","invalidXML","getElementsByTagName","namespaceURI","ignored","parserErrors","getElementsByTagNameNS","length","Error","item","innerHTML","isElement","node","attributes","asElementWithAttributes","hasAttributes","undefined","result","childNodeCount","firstChildNode","onlyChildTextValue","nodeType","Node","TEXT_NODE","nodeValue","elementWithAttributes","i","attr","nodeName","child","childObject","Array","isArray","push","doc","document","implementation","createDocument","serializer","XMLSerializer","stringifyXML","opts","rootName","buildNode","serializeToString","buildAttributes","attrs","_a","keys","_i","key","createAttribute","value","toString","elementName","elem","createElement","textContent","obj_1","arrayElem","_b","_d","_c","_f","_e","setNamedItem","_h","_g","appendChild"],"sources":["C:\\Users\\willi\\Downloads\\azure-main\\node_modules\\@azure\\ms-rest-js\\lib\\util\\xml.browser.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nconst parser = new DOMParser();\n\n// Policy to make our code Trusted Types compliant.\n//   https://github.com/w3c/webappsec-trusted-types\n// We are calling DOMParser.parseFromString() to parse XML payload from Azure services.\n// The parsed DOM object is not exposed to outside. Scripts are disabled when parsing\n// according to the spec.  There are no HTML/XSS security concerns on the usage of\n// parseFromString() here.\nlet ttPolicy: Pick<TrustedTypePolicy, \"createHTML\"> | undefined;\nif (typeof self.trustedTypes !== \"undefined\") {\n  ttPolicy = self.trustedTypes.createPolicy(\"@azure/ms-rest-js#xml.browser\", {\n    createHTML: (s) => s,\n  });\n}\n\nexport function parseXML(str: string): Promise<any> {\n  try {\n    const dom = parser.parseFromString((ttPolicy?.createHTML(str) ?? str) as string, \"application/xml\");\n    throwIfError(dom);\n\n    const obj = domToObject(dom.childNodes[0]);\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\nlet errorNS = \"\";\ntry {\n  const invalidXML = (ttPolicy?.createHTML(\"INVALID\") ?? \"INVALID\") as string;\n  errorNS =\n    parser.parseFromString(invalidXML, \"text/xml\").getElementsByTagName(\"parsererror\")[0]\n      .namespaceURI! ?? \"\";\n} catch (ignored) {\n  // Most browsers will return a document containing <parsererror>, but IE will throw.\n}\n\nfunction throwIfError(dom: Document) {\n  if (errorNS) {\n    const parserErrors = dom.getElementsByTagNameNS(errorNS, \"parsererror\");\n    if (parserErrors.length) {\n      throw new Error(parserErrors.item(0)!.innerHTML);\n    }\n  }\n}\n\nfunction isElement(node: Node): node is Element {\n  return !!(node as Element).attributes;\n}\n\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node: Node): Element | undefined {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\n\nfunction domToObject(node: Node): any {\n  let result: any = {};\n\n  const childNodeCount: number = node.childNodes.length;\n\n  const firstChildNode: Node = node.childNodes[0];\n  const onlyChildTextValue: string | undefined =\n    (firstChildNode &&\n      childNodeCount === 1 &&\n      firstChildNode.nodeType === Node.TEXT_NODE &&\n      firstChildNode.nodeValue) ||\n    undefined;\n\n  const elementWithAttributes: Element | undefined = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[\"$\"] = {};\n\n    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {\n      const attr = elementWithAttributes.attributes[i];\n      result[\"$\"][attr.nodeName] = attr.nodeValue;\n    }\n\n    if (onlyChildTextValue) {\n      result[\"_\"] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n\n  if (!onlyChildTextValue) {\n    for (let i = 0; i < childNodeCount; i++) {\n      const child = node.childNodes[i];\n      // Ignore leading/trailing whitespace nodes\n      if (child.nodeType !== Node.TEXT_NODE) {\n        const childObject: any = domToObject(child);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n// tslint:disable-next-line:no-null-keyword\nconst doc = document.implementation.createDocument(null, null, null);\nconst serializer = new XMLSerializer();\n\nexport function stringifyXML(obj: any, opts?: { rootName?: string }) {\n  const rootName = (opts && opts.rootName) || \"root\";\n  const dom = buildNode(obj, rootName)[0];\n  return (\n    '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + serializer.serializeToString(dom)\n  );\n}\n\nfunction buildAttributes(attrs: { [key: string]: { toString(): string } }): Attr[] {\n  const result = [];\n  for (const key of Object.keys(attrs)) {\n    const attr = doc.createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\n\nfunction buildNode(obj: any, elementName: string): Node[] {\n  if (typeof obj === \"string\" || typeof obj === \"number\" || typeof obj === \"boolean\") {\n    const elem = doc.createElement(elementName);\n    elem.textContent = obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    const result = [];\n    for (const arrayElem of obj) {\n      for (const child of buildNode(arrayElem, elementName)) {\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    const elem = doc.createElement(elementName);\n    for (const key of Object.keys(obj)) {\n      if (key === \"$\") {\n        for (const attr of buildAttributes(obj[key])) {\n          elem.attributes.setNamedItem(attr);\n        }\n      } else {\n        for (const child of buildNode(obj[key], key)) {\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(`Illegal value passed to buildObject: ${obj}`);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}