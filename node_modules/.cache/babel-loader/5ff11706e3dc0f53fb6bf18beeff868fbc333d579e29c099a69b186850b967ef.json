{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport { v4 as uuidv4 } from \"uuid\";\nimport { Constants } from \"./constants\";\n/**\n * A constant that indicates whether the environment is node.js or browser based.\n */\nexport var isNode = typeof process !== \"undefined\" && !!process.version && !!process.versions && !!process.versions.node;\n/**\n * Checks if a parsed URL is HTTPS\n *\n * @param {object} urlToCheck The url to check\n * @return {boolean} True if the URL is HTTPS; false otherwise.\n */\nexport function urlIsHTTPS(urlToCheck) {\n  return urlToCheck.protocol.toLowerCase() === Constants.HTTPS;\n}\n/**\n * Encodes an URI.\n *\n * @param {string} uri The URI to be encoded.\n * @return {string} The encoded URI.\n */\nexport function encodeUri(uri) {\n  return encodeURIComponent(uri).replace(/!/g, \"%21\").replace(/\"/g, \"%27\").replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\").replace(/\\*/g, \"%2A\");\n}\n/**\n * Returns a stripped version of the Http Response which only contains body,\n * headers and the status.\n *\n * @param {HttpOperationResponse} response The Http Response\n *\n * @return {object} The stripped version of Http Response.\n */\nexport function stripResponse(response) {\n  var strippedResponse = {};\n  strippedResponse.body = response.bodyAsText;\n  strippedResponse.headers = response.headers;\n  strippedResponse.status = response.status;\n  return strippedResponse;\n}\n/**\n * Returns a stripped version of the Http Request that does not contain the\n * Authorization header.\n *\n * @param {WebResource} request The Http Request object\n *\n * @return {WebResource} The stripped version of Http Request.\n */\nexport function stripRequest(request) {\n  var strippedRequest = request.clone();\n  if (strippedRequest.headers) {\n    strippedRequest.headers.remove(\"authorization\");\n  }\n  return strippedRequest;\n}\n/**\n * Validates the given uuid as a string\n *\n * @param {string} uuid The uuid as a string that needs to be validated\n *\n * @return {boolean} True if the uuid is valid; false otherwise.\n */\nexport function isValidUuid(uuid) {\n  var validUuidRegex = new RegExp(\"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\", \"ig\");\n  return validUuidRegex.test(uuid);\n}\n/**\n * Provides an array of values of an object. For example\n * for a given object { \"a\": \"foo\", \"b\": \"bar\" }, the method returns [\"foo\", \"bar\"].\n *\n * @param {object} obj An object whose properties need to be enumerated so that it\"s values can be provided as an array\n *\n * @return {any[]} An array of values of the given object.\n */\nexport function objectValues(obj) {\n  var result = [];\n  if (obj && obj instanceof Object) {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        result.push(obj[key]);\n      }\n    }\n  } else {\n    throw new Error(\"The provided object \" + JSON.stringify(obj, undefined, 2) + \" is not a valid object that can be \" + \"enumerated to provide its values as an array.\");\n  }\n  return result;\n}\n/**\n * Generated UUID\n *\n * @return {string} RFC4122 v4 UUID.\n */\nexport function generateUuid() {\n  return uuidv4();\n}\n/**\n * Executes an array of promises sequentially. Inspiration of this method is here:\n * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!\n *\n * @param {Array} promiseFactories An array of promise factories(A function that return a promise)\n *\n * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.\n * If not provided then the promise chain starts with undefined.\n *\n * @return A chain of resolved or rejected promises\n */\nexport function executePromisesSequentially(promiseFactories, kickstart) {\n  var result = Promise.resolve(kickstart);\n  promiseFactories.forEach(function (promiseFactory) {\n    result = result.then(promiseFactory);\n  });\n  return result;\n}\n/**\n * Merges source object into the target object\n * @param {object} source The object that needs to be merged\n *\n * @param {object} target The object to be merged into\n *\n * @returns {object} Returns the merged target object.\n */\nexport function mergeObjects(source, target) {\n  Object.keys(source).forEach(function (key) {\n    target[key] = source[key];\n  });\n  return target;\n}\n/**\n * A wrapper for setTimeout that resolves a promise after t milliseconds.\n * @param {number} t The number of milliseconds to be delayed.\n * @param {T} value The value to be resolved with after a timeout of t milliseconds.\n * @returns {Promise<T>} Resolved promise\n */\nexport function delay(t, value) {\n  return new Promise(function (resolve) {\n    return setTimeout(function () {\n      return resolve(value);\n    }, t);\n  });\n}\n/**\n * Converts a Promise to a callback.\n * @param {Promise<any>} promise The Promise to be converted to a callback\n * @returns {Function} A function that takes the callback (cb: Function): void\n * @deprecated generated code should instead depend on responseToBody\n */\nexport function promiseToCallback(promise) {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  }\n  return function (cb) {\n    promise.then(function (data) {\n      cb(undefined, data);\n    }, function (err) {\n      cb(err);\n    });\n  };\n}\n/**\n * Converts a Promise to a service callback.\n * @param {Promise<HttpOperationResponse>} promise - The Promise of HttpOperationResponse to be converted to a service callback\n * @returns {Function} A function that takes the service callback (cb: ServiceCallback<T>): void\n */\nexport function promiseToServiceCallback(promise) {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  }\n  return function (cb) {\n    promise.then(function (data) {\n      process.nextTick(cb, undefined, data.parsedBody, data.request, data);\n    }, function (err) {\n      process.nextTick(cb, err);\n    });\n  };\n}\nexport function prepareXMLRootList(obj, elementName) {\n  var _a;\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n  return _a = {}, _a[elementName] = obj, _a;\n}\n/**\n * Applies the properties on the prototype of sourceCtors to the prototype of targetCtor\n * @param {object} targetCtor The target object on which the properties need to be applied.\n * @param {Array<object>} sourceCtors An array of source objects from which the properties need to be taken.\n */\nexport function applyMixins(targetCtor, sourceCtors) {\n  sourceCtors.forEach(function (sourceCtors) {\n    Object.getOwnPropertyNames(sourceCtors.prototype).forEach(function (name) {\n      targetCtor.prototype[name] = sourceCtors.prototype[name];\n    });\n  });\n}\nvar validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Indicates whether the given string is in ISO 8601 format.\n * @param {string} value The value to be validated for ISO 8601 duration format.\n * @return {boolean} `true` if valid, `false` otherwise.\n */\nexport function isDuration(value) {\n  return validateISODuration.test(value);\n}\n/**\n * Replace all of the instances of searchValue in value with the provided replaceValue.\n * @param {string | undefined} value The value to search and replace in.\n * @param {string} searchValue The value to search for in the value argument.\n * @param {string} replaceValue The value to replace searchValue with in the value argument.\n * @returns {string | undefined} The value where each instance of searchValue was replaced with replacedValue.\n */\nexport function replaceAll(value, searchValue, replaceValue) {\n  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || \"\");\n}\n/**\n * Determines whether the given enity is a basic/primitive type\n * (string, number, boolean, null, undefined).\n * @param value Any entity\n * @return boolean - true is it is primitive type, false otherwise.\n */\nexport function isPrimitiveType(value) {\n  return typeof value !== \"object\" && typeof value !== \"function\" || value === null;\n}","map":{"version":3,"mappings":"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","names":["v4","uuidv4","Constants","isNode","process","version","versions","node","urlIsHTTPS","urlToCheck","protocol","toLowerCase","HTTPS","encodeUri","uri","encodeURIComponent","replace","stripResponse","response","strippedResponse","body","bodyAsText","headers","status","stripRequest","request","strippedRequest","clone","remove","isValidUuid","uuid","validUuidRegex","RegExp","test","objectValues","obj","result","Object","key","hasOwnProperty","push","Error","JSON","stringify","undefined","generateUuid","executePromisesSequentially","promiseFactories","kickstart","Promise","resolve","forEach","promiseFactory","then","mergeObjects","source","target","keys","delay","t","value","promiseToCallback","promise","cb","data","err","promiseToServiceCallback","nextTick","parsedBody","prepareXMLRootList","elementName","Array","isArray","_a","applyMixins","targetCtor","sourceCtors","getOwnPropertyNames","prototype","name","validateISODuration","isDuration","replaceAll","searchValue","replaceValue","split","join","isPrimitiveType"],"sources":["C:\\Users\\willi\\Downloads\\azure-main\\node_modules\\@azure\\ms-rest-js\\lib\\util\\utils.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nimport { v4 as uuidv4 } from \"uuid\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { RestError } from \"../restError\";\nimport { WebResourceLike } from \"../webResource\";\nimport { Constants } from \"./constants\";\n\n/**\n * A constant that indicates whether the environment is node.js or browser based.\n */\nexport const isNode =\n  typeof process !== \"undefined\" &&\n  !!process.version &&\n  !!process.versions &&\n  !!process.versions.node;\n\n/**\n * Checks if a parsed URL is HTTPS\n *\n * @param {object} urlToCheck The url to check\n * @return {boolean} True if the URL is HTTPS; false otherwise.\n */\nexport function urlIsHTTPS(urlToCheck: { protocol: string }): boolean {\n  return urlToCheck.protocol.toLowerCase() === Constants.HTTPS;\n}\n\n/**\n * Encodes an URI.\n *\n * @param {string} uri The URI to be encoded.\n * @return {string} The encoded URI.\n */\nexport function encodeUri(uri: string): string {\n  return encodeURIComponent(uri)\n    .replace(/!/g, \"%21\")\n    .replace(/\"/g, \"%27\")\n    .replace(/\\(/g, \"%28\")\n    .replace(/\\)/g, \"%29\")\n    .replace(/\\*/g, \"%2A\");\n}\n\n/**\n * Returns a stripped version of the Http Response which only contains body,\n * headers and the status.\n *\n * @param {HttpOperationResponse} response The Http Response\n *\n * @return {object} The stripped version of Http Response.\n */\nexport function stripResponse(response: HttpOperationResponse): any {\n  const strippedResponse: any = {};\n  strippedResponse.body = response.bodyAsText;\n  strippedResponse.headers = response.headers;\n  strippedResponse.status = response.status;\n  return strippedResponse;\n}\n\n/**\n * Returns a stripped version of the Http Request that does not contain the\n * Authorization header.\n *\n * @param {WebResource} request The Http Request object\n *\n * @return {WebResource} The stripped version of Http Request.\n */\nexport function stripRequest(request: WebResourceLike): WebResourceLike {\n  const strippedRequest = request.clone();\n  if (strippedRequest.headers) {\n    strippedRequest.headers.remove(\"authorization\");\n  }\n  return strippedRequest;\n}\n\n/**\n * Validates the given uuid as a string\n *\n * @param {string} uuid The uuid as a string that needs to be validated\n *\n * @return {boolean} True if the uuid is valid; false otherwise.\n */\nexport function isValidUuid(uuid: string): boolean {\n  const validUuidRegex = new RegExp(\n    \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\",\n    \"ig\"\n  );\n  return validUuidRegex.test(uuid);\n}\n\n/**\n * Provides an array of values of an object. For example\n * for a given object { \"a\": \"foo\", \"b\": \"bar\" }, the method returns [\"foo\", \"bar\"].\n *\n * @param {object} obj An object whose properties need to be enumerated so that it\"s values can be provided as an array\n *\n * @return {any[]} An array of values of the given object.\n */\nexport function objectValues(obj: { [key: string]: any }): any[] {\n  const result: any[] = [];\n  if (obj && obj instanceof Object) {\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        result.push((<any>obj)[key]);\n      }\n    }\n  } else {\n    throw new Error(\n      `The provided object ${JSON.stringify(\n        obj,\n        undefined,\n        2\n      )} is not a valid object that can be ` + `enumerated to provide its values as an array.`\n    );\n  }\n  return result;\n}\n\n/**\n * Generated UUID\n *\n * @return {string} RFC4122 v4 UUID.\n */\nexport function generateUuid(): string {\n  return uuidv4();\n}\n\n/**\n * Executes an array of promises sequentially. Inspiration of this method is here:\n * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!\n *\n * @param {Array} promiseFactories An array of promise factories(A function that return a promise)\n *\n * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.\n * If not provided then the promise chain starts with undefined.\n *\n * @return A chain of resolved or rejected promises\n */\nexport function executePromisesSequentially(promiseFactories: Array<any>, kickstart: any) {\n  let result = Promise.resolve(kickstart);\n  promiseFactories.forEach((promiseFactory) => {\n    result = result.then(promiseFactory);\n  });\n  return result;\n}\n\n/**\n * Merges source object into the target object\n * @param {object} source The object that needs to be merged\n *\n * @param {object} target The object to be merged into\n *\n * @returns {object} Returns the merged target object.\n */\nexport function mergeObjects(source: { [key: string]: any }, target: { [key: string]: any }) {\n  Object.keys(source).forEach((key) => {\n    target[key] = source[key];\n  });\n  return target;\n}\n\n/**\n * A wrapper for setTimeout that resolves a promise after t milliseconds.\n * @param {number} t The number of milliseconds to be delayed.\n * @param {T} value The value to be resolved with after a timeout of t milliseconds.\n * @returns {Promise<T>} Resolved promise\n */\nexport function delay<T>(t: number, value?: T): Promise<T> {\n  return new Promise((resolve) => setTimeout(() => resolve(value), t));\n}\n\n/**\n * Service callback that is returned for REST requests initiated by the service client.\n */\nexport interface ServiceCallback<TResult> {\n  /**\n   * A method that will be invoked as a callback to a service function.\n   * @param {Error | RestError | null} err The error occurred if any, while executing the request; otherwise null.\n   * @param {TResult} [result] The deserialized response body if an error did not occur.\n   * @param {WebResourceLike} [request] The raw/actual request sent to the server if an error did not occur.\n   * @param {HttpOperationResponse} [response] The raw/actual response from the server if an error did not occur.\n   */\n  (\n    err: Error | RestError | null,\n    result?: TResult,\n    request?: WebResourceLike,\n    response?: HttpOperationResponse\n  ): void;\n}\n\n/**\n * Converts a Promise to a callback.\n * @param {Promise<any>} promise The Promise to be converted to a callback\n * @returns {Function} A function that takes the callback (cb: Function): void\n * @deprecated generated code should instead depend on responseToBody\n */\nexport function promiseToCallback(promise: Promise<any>): Function {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  }\n  return (cb: Function): void => {\n    promise.then(\n      (data: any) => {\n        cb(undefined, data);\n      },\n      (err: Error) => {\n        cb(err);\n      }\n    );\n  };\n}\n\n/**\n * Converts a Promise to a service callback.\n * @param {Promise<HttpOperationResponse>} promise - The Promise of HttpOperationResponse to be converted to a service callback\n * @returns {Function} A function that takes the service callback (cb: ServiceCallback<T>): void\n */\nexport function promiseToServiceCallback<T>(promise: Promise<HttpOperationResponse>): Function {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  }\n  return (cb: ServiceCallback<T>): void => {\n    promise.then(\n      (data: HttpOperationResponse) => {\n        process.nextTick(cb, undefined, data.parsedBody as T, data.request, data);\n      },\n      (err: Error) => {\n        process.nextTick(cb, err);\n      }\n    );\n  };\n}\n\nexport function prepareXMLRootList(obj: any, elementName: string) {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n  return { [elementName]: obj };\n}\n\n/**\n * Applies the properties on the prototype of sourceCtors to the prototype of targetCtor\n * @param {object} targetCtor The target object on which the properties need to be applied.\n * @param {Array<object>} sourceCtors An array of source objects from which the properties need to be taken.\n */\nexport function applyMixins(targetCtor: any, sourceCtors: any[]): void {\n  sourceCtors.forEach((sourceCtors) => {\n    Object.getOwnPropertyNames(sourceCtors.prototype).forEach((name) => {\n      targetCtor.prototype[name] = sourceCtors.prototype[name];\n    });\n  });\n}\n\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n/**\n * Indicates whether the given string is in ISO 8601 format.\n * @param {string} value The value to be validated for ISO 8601 duration format.\n * @return {boolean} `true` if valid, `false` otherwise.\n */\nexport function isDuration(value: string): boolean {\n  return validateISODuration.test(value);\n}\n\n/**\n * Replace all of the instances of searchValue in value with the provided replaceValue.\n * @param {string | undefined} value The value to search and replace in.\n * @param {string} searchValue The value to search for in the value argument.\n * @param {string} replaceValue The value to replace searchValue with in the value argument.\n * @returns {string | undefined} The value where each instance of searchValue was replaced with replacedValue.\n */\nexport function replaceAll(\n  value: string | undefined,\n  searchValue: string,\n  replaceValue: string\n): string | undefined {\n  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || \"\");\n}\n\n/**\n * Determines whether the given enity is a basic/primitive type\n * (string, number, boolean, null, undefined).\n * @param value Any entity\n * @return boolean - true is it is primitive type, false otherwise.\n */\nexport function isPrimitiveType(value: any): boolean {\n  return (typeof value !== \"object\" && typeof value !== \"function\") || value === null;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}